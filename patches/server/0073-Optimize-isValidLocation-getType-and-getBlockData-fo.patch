From 7561e692a7b7b349adeb17447381db133b1c1853 Mon Sep 17 00:00:00 2001
From: cswhite2000 <18whitechristop@gmail.com>
Date: Sun, 12 Aug 2018 01:41:23 -0700
Subject: [PATCH] Optimize isValidLocation, getType and getBlockData for inling

Hot methods, so reduce # of instructions for the method.

Move is valid location test to the BlockPosition class so that it can access local variables.

Replace all calls to the new place to the unnecessary forward.

Optimize getType and getBlockData to manually inline and optimize the calls

diff --git a/src/main/java/net/minecraft/server/BaseBlockPosition.java b/src/main/java/net/minecraft/server/BaseBlockPosition.java
index a685e081..11df25f2 100644
--- a/src/main/java/net/minecraft/server/BaseBlockPosition.java
+++ b/src/main/java/net/minecraft/server/BaseBlockPosition.java
@@ -9,6 +9,9 @@ public class BaseBlockPosition implements Comparable<BaseBlockPosition> {
     protected int a;
     protected int c;
     protected int d;
+    public boolean isValidLocation() {
+        return a >= -30000000 && d >= -30000000 && a < 30000000 && d < 30000000 && c >= 0 && c < 256;
+    }
     // PaperSpigot end
 
     public BaseBlockPosition(int i, int j, int k) {
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 0faa0bcb..35dbc374 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -501,14 +501,21 @@ public class Chunk {
 
     // PaperSpigot start - Optimize getBlockData
     public IBlockData getBlockData(final BlockPosition blockposition) {
-        if (blockposition.getY() >= 0 && blockposition.getY() >> 4 < this.sections.length) {
-            ChunkSection chunksection = this.sections[blockposition.getY() >> 4];
+        return getBlockData(blockposition.getX(), blockposition.getY(), blockposition.getZ());
+    }
+
+    public final IBlockData getBlockData(final int x, final int y, final int z) {
+        if (y >= 0 && y >> 4 < this.sections.length) {
+            ChunkSection chunksection = this.sections[y >> 4];
             if (chunksection != null) {
-                return chunksection.getType(blockposition.getX() & 15, blockposition.getY() & 15, blockposition.getZ() & 15);
+                IBlockData iblockdata = (IBlockData) Block.d.a(chunksection.blockIds[(x & 15) << 8 | (z & 15) << 4 | x & 15]);
+
+                return iblockdata != null ? iblockdata : Blocks.AIR.getBlockData();
             }
         }
         return Blocks.AIR.getBlockData();
     }
+
     public IBlockData getBlockDataSlow(final BlockPosition blockposition) {
         // PaperSpigot end
         if (this.world.G() == WorldType.DEBUG_ALL_BLOCK_STATES) {
diff --git a/src/main/java/net/minecraft/server/ChunkSection.java b/src/main/java/net/minecraft/server/ChunkSection.java
index 907c57b8..72592a2f 100644
--- a/src/main/java/net/minecraft/server/ChunkSection.java
+++ b/src/main/java/net/minecraft/server/ChunkSection.java
@@ -5,7 +5,7 @@ public class ChunkSection {
     private int yPos;
     private int nonEmptyBlockCount;
     private int tickingBlockCount;
-    private char[] blockIds;
+    public char[] blockIds;// Paper
     private NibbleArray emittedLight;
     private NibbleArray skyLight;
     boolean isDirty; // PaperSpigot
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 6dd39cf0..b810e8b0 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -292,8 +292,8 @@ public abstract class World implements IBlockAccess {
         return this.getType(blockposition1).getBlock();
     }
 
-    private boolean isValidLocation(BlockPosition blockposition) {
-        return blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() < 30000000 && blockposition.getY() >= 0 && blockposition.getY() < 256;
+    private static boolean isValidLocation(BlockPosition blockposition) { // Paper - unused but incase reflection / future uses
+        return blockposition.isValidLocation(); // Paper
     }
 
     public boolean isEmpty(BlockPosition blockposition) {
@@ -305,7 +305,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public boolean a(BlockPosition blockposition, boolean flag) {
-        return !this.isValidLocation(blockposition) ? false : this.isChunkLoaded(blockposition.getX() >> 4, blockposition.getZ() >> 4, flag);
+        return !blockposition.isValidLocation() ? false : this.isChunkLoaded(blockposition.getX() >> 4, blockposition.getZ() >> 4, flag);// Paper
     }
 
     public boolean areChunksLoaded(BlockPosition blockposition, int i) {
@@ -387,7 +387,8 @@ public abstract class World implements IBlockAccess {
             return true;
         }
         // CraftBukkit end
-        if (!this.isValidLocation(blockposition)) {
+        // Paper - unused but incase reflection / future uses
+        if (!blockposition.isValidLocation()) {
             return false;
         } else if (!this.isClientSide && this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             return false;
@@ -737,7 +738,8 @@ public abstract class World implements IBlockAccess {
             blockposition = new BlockPosition(blockposition.getX(), 0, blockposition.getZ());
         }
 
-        if (!this.isValidLocation(blockposition)) {
+        // Paper - unused but incase reflection / future uses
+        if (!blockposition.isValidLocation()) {
             return enumskyblock.c;
         } else if (!this.isLoaded(blockposition)) {
             return enumskyblock.c;
@@ -749,7 +751,8 @@ public abstract class World implements IBlockAccess {
     }
 
     public void a(EnumSkyBlock enumskyblock, BlockPosition blockposition, int i) {
-        if (this.isValidLocation(blockposition)) {
+        // Paper - unused but incase reflection / future uses
+        if (blockposition.isValidLocation()) {
             if (this.isLoaded(blockposition)) {
                 Chunk chunk = this.getChunkAtWorldCoords(blockposition);
 
@@ -773,19 +776,19 @@ public abstract class World implements IBlockAccess {
     // Paper start - reduces need to do isLoaded before getType
     public IBlockData getTypeIfLoaded(BlockPosition blockposition) {
         // CraftBukkit start - tree generation
+        final int x = blockposition.getX();
+        final int y = blockposition.getY();
+        final int z = blockposition.getZ();
         if (captureTreeGeneration) {
-            Iterator<BlockState> it = capturedBlockStates.iterator();
-            while (it.hasNext()) {
-                BlockState previous = it.next();
-                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
-                    return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
-                }
+            final IBlockData previous = getCapturedBlockType(x, y, z);
+            if (previous != null) {
+                return previous;
             }
         }
         // CraftBukkit end
-        Chunk chunk = this.getChunkIfLoaded(blockposition);
+        Chunk chunk = ((ChunkProviderServer) this.chunkProvider).getChunkIfLoaded(x >> 4, z >> 4);
         if (chunk != null) {
-            return this.isValidLocation(blockposition) ? chunk.getBlockData(blockposition) : Blocks.AIR.getBlockData();
+            return chunk.getBlockData(x, y, z);
         }
         return null;
     }
@@ -798,25 +801,36 @@ public abstract class World implements IBlockAccess {
     
     public IBlockData getType(BlockPosition blockposition, boolean useCaptured) {
         // CraftBukkit start - tree generation
+        // Paper start - optimize getType lookup to reduce instructions - getBlockData already enforces valid Y, move tree out
+        final int x = blockposition.getX();
+        final int y = blockposition.getY();
+        final int z = blockposition.getZ();
         if (captureTreeGeneration && useCaptured) {
     // Spigot end
-            Iterator<BlockState> it = capturedBlockStates.iterator();
-            while (it.hasNext()) {
-                BlockState previous = it.next();
-                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
-                    return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
-                }
+            final IBlockData previous = getCapturedBlockType(x, y, z);
+            if (previous != null) {
+                return previous;
             }
         }
         // CraftBukkit end
-        if (!this.isValidLocation(blockposition)) {
-            return Blocks.AIR.getBlockData();
-        } else {
-            Chunk chunk = this.getChunkAtWorldCoords(blockposition);
+        chunkProvider.getChunkAt(chunkProvider, x>> 4, z >> 4);
+
+        return this.getChunkAt(x >> 4, z >> 4).getBlockData(x, y, z);
+        // Paper end
+    }
 
-            return chunk.getBlockData(blockposition);
+    // Paper start
+    private IBlockData getCapturedBlockType(int x, int y, int z) {
+        Iterator<BlockState> it = capturedBlockStates.iterator();
+        while (it.hasNext()) {
+            BlockState previous = it.next();
+            if (previous.getX() == x && previous.getY() == y && previous.getZ() == z) {
+                return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
+            }
         }
+        return null;
     }
+    // Paper end
 
     public boolean w() {
         return this.I < 4;
@@ -2038,7 +2052,8 @@ public abstract class World implements IBlockAccess {
     public Map<BlockPosition, TileEntity> capturedTileEntities = Maps.newHashMap();
 
     public TileEntity getTileEntity(BlockPosition blockposition) {
-        if (!this.isValidLocation(blockposition)) {
+        // Paper - unused but incase reflection / future uses
+        if (!blockposition.isValidLocation()) {
             return null;
         } else {
             // CraftBukkit start
@@ -2149,7 +2164,8 @@ public abstract class World implements IBlockAccess {
     }
 
     public boolean d(BlockPosition blockposition, boolean flag) {
-        if (!this.isValidLocation(blockposition)) {
+        // Paper - unused but incase reflection / future uses
+        if (!blockposition.isValidLocation()) {
             return flag;
         } else {
             Chunk chunk = this.chunkProvider.getChunkAt(blockposition);
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
index ecef909a..52bb897b 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
@@ -110,7 +110,7 @@ public class CraftBlock implements Block {
     }
 
     public byte getData() {
-        IBlockData blockData = chunk.getHandle().getBlockData(new BlockPosition(x, y, z));
+        IBlockData blockData = chunk.getHandle().getBlockData(x, y, z);
         return (byte) blockData.getBlock().toLegacyData(blockData);
     }
 
-- 
2.18.0

